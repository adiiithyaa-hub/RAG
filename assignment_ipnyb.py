# -*- coding: utf-8 -*-
"""Assignment.ipnyb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HM7FFzW40hJnbDVa0eCqKkhilGwDEqjA
"""

from pydantic import field_validator
import streamlit as st
import os
import json
from enum import Enum
from typing import List, NamedTuple, Dict, Optional, Union
from anthropic import Anthropic, BaseModel
import tiktoken
import anthropic
os.environ["ANTHROPIC_API_KEY"] = "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"
client = anthropic.Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))


# Define FieldType enum
class FieldType(Enum):
    TEXT = "text"
    NUMBER = "number"
    DATE = "date"

# Pydantic models
class ExtractedField(BaseModel):
    value: Optional[Union[str, int, float]] = None
    reference: Optional[str] = None

    @field_validator("reference", mode="before")
    @classmethod
    def set_reference(cls, v):
        return v or ""

class UserDefinedField(BaseModel):
    name: str
    description: str
    field_type: FieldType

    @field_validator("name", "field_type", mode="before")
    @classmethod
    def check_empty(cls, v):
        if not v:
            raise ValueError("This field cannot be empty.")
        return v

# Helper functions
def safe_json_loads(json_string: str) -> Dict:
    try:
        return json.loads(json_string)
    except json.JSONDecodeError:
        st.error(f"Failed to parse JSON: {json_string}")
        return {}

def format_fields(fields: List[UserDefinedField]) -> str:
    formatted_fields = []
    for field in fields:
        field_info = f"- {field.name}: {field.description}\n"
        field_info += f"  Expected type: {field.field_type.value}\n"
        if field.field_type == FieldType.DATE:
            field_info += "  Format: YYYY-MM-DD\n"
        elif field.field_type == FieldType.NUMBER:
            field_info += "  Format: Numerical value (use period for decimal point)\n"
        formatted_fields.append(field_info)
    return "\n".join(formatted_fields)


# Main extraction function
def extract_document_info(data: str, fields: List[UserDefinedField]) -> Dict[str, ExtractedField]:
    result = {}
    chunk_size = 2000  # Tokens per chunk, leaving room for prompt and response
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]

    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        st.error("Anthropic API key not found. Please set the ANTHROPIC_API_KEY environment variable.")
        return {}

    client = Anthropic(api_key=api_key)

    for i, chunk in enumerate(chunks):
        st.write(f"Processing chunk {i+1} of {len(chunks)}...")

        field_prompt = f"""
        You are an expert in extracting specific information from documents. Your task is to accurately extract the following fields from the given document chunk. Be precise and thorough in your analysis.

        Fields to extract:
        {format_fields(fields)}

        Document chunk {i+1} of {len(chunks)}:
        {chunk}

        Instructions:
        1. Carefully read the document chunk and identify the exact information requested for each field.
        2. For each field, provide:
           - The extracted value, matching the expected type.
           - The full sentence or specific context where the information was found.
        3. If a field is not present in this chunk, set its value to null and leave the reference empty.
        4. Ensure all extracted values are accurate and directly supported by the text.
        5. Do not infer or guess information not explicitly stated in the document.
        6. Pay close attention to units, formatting, and context when extracting numerical or date values.
        7. For fields expecting a specific format (e.g., dates, currency), ensure the extracted value matches that format.


        Format your response as a JSON object with this structure:
        {{
          "field_name": {{"value": "extracted_value", "reference": "supporting context"}},
          ...
        }}

        Remember: Accuracy is crucial. Only extract information you are confident is correct based on the document text.

        Extracted Information:
        """


        try:
            response = client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=1000,
                system="You are a helpful assistant that extracts specific information from document chunks.",
                messages=[
                    {"role": "user", "content": field_prompt}
                ]
            )

            extracted_text = response.content[0].text if isinstance(response.content, list) and len(response.content) > 0 else response.content

            if st.session_state.debug_mode:
                st.write(f"Debug - Raw API response for chunk {i+1}:")
                st.code(extracted_text, language="text")

            extracted_data = safe_json_loads(extracted_text)

            if st.session_state.debug_mode:
                st.write(f"Debug - Parsed data structure for chunk {i+1}:")
                st.write(extracted_data)

            if not extracted_data:
                st.warning(f"No valid data extracted from chunk {i+1}. Skipping this chunk.")
                continue

            for field in fields:
                field_data = extracted_data.get(field.name, {})
                if isinstance(field_data, dict) and 'value' in field_data and field_data['value'] is not None:
                    new_value = field_data.get('value')
                    new_reference = field_data.get('reference', '')

                    if field.name not in result:
                        result[field.name] = ExtractedField(
                            value=new_value,
                            reference=new_reference
                        )
                    else:
                        # Merge the new data with existing data
                        existing_value = result[field.name].value
                        existing_reference = result[field.name].reference

                        if isinstance(existing_value, (int, float)) and isinstance(new_value, (int, float)):
                            # For numerical values, we'll sum them up
                            result[field.name].value = existing_value + new_value
                        elif isinstance(existing_value, str) and isinstance(new_value, str):
                            # For string values, we'll concatenate them
                            result[field.name].value = f"{existing_value}; {new_value}"
                        else:
                            # For mixed types or other cases, we'll keep the non-null value
                            result[field.name].value = new_value if new_value is not None else existing_value

                        # Concatenate references
                        result[field.name].reference = f"{existing_reference}; {new_reference}".strip('; ')

            if st.session_state.debug_mode:
                st.write(f"Debug - Current result after chunk {i+1}:")
                st.write(result)

        except Exception as e:
            st.error(f"An error occurred while processing chunk {i+1}: {str(e)}")
            continue

    for field in fields:
                field_data = extracted_data.get(field.name, {})
                if isinstance(field_data, dict) and 'value' in field_data and field_data['value'] is not None:
                    new_value = field_data.get('value')
                    new_reference = field_data.get('reference', '')

                    if field.name not in result:
                        result[field.name] = ExtractedField(
                            value=new_value,
                            reference=new_reference
                        )
                    else:
                        existing_value = result[field.name].value
                        existing_reference = result[field.name].reference

                        if isinstance(existing_value, (int, float)) and isinstance(new_value, (int, float)):
                            result[field.name].value = existing_value + new_value
                        elif isinstance(existing_value, str) and isinstance(new_value, str):
                            # Handle potential duplicates in string values
                            existing_items = existing_value.split('; ')
                            new_items = new_value.split('; ')
                            combined_items = list(dict.fromkeys(existing_items + new_items))
                            result[field.name].value = '; '.join(combined_items)
                        else:
                            result[field.name].value = new_value if new_value is not None else existing_value

                        all_references = (existing_reference + '; ' + new_reference).split('; ')
                        unique_references = list(dict.fromkeys(all_references))
                        result[field.name].reference = '; '.join(unique_references).strip('; ')



    return result



def validate_extracted_info(extracted_fields: Dict[str, ExtractedField], fields: List[UserDefinedField]) -> Dict[str, str]:
    validation_results = {}
    for field in fields:
        extracted = extracted_fields.get(field.name)
        if extracted and extracted.value:
            if field.field_type == FieldType.NUMBER:
                try:
                    float(extracted.value)
                    validation_results[field.name] = "Valid"
                except ValueError:
                    validation_results[field.name] = "Invalid: Not a number"
            elif field.field_type == FieldType.DATE:
                # Simple date validation (you might want to use a library like dateutil for more robust validation)
                if not any(char.isalpha() for char in extracted.value) and any(char.isdigit() for char in extracted.value):
                    validation_results[field.name] = "Valid"
                else:
                    validation_results[field.name] = "Invalid: Not a date"
            else:
                validation_results[field.name] = "Valid"
        else:
            validation_results[field.name] = "Not found"
    return validation_results

def main():
    st.title("Document Information Extractor")

    # Check for API key
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        st.error("Anthropic API key not found. Please set the ANTHROPIC_API_KEY environment variable.")
        return

    # Initialize session state
    if 'fields' not in st.session_state:
        st.session_state.fields = []
    if 'debug_mode' not in st.session_state:
        st.session_state.debug_mode = False

    # Field definition section
    st.header("Choose Field")

    # Display defined field and remove button
    if st.session_state.fields:
        st.subheader("Defined Field:")
        field = st.session_state.fields[0]
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write(f"- {field.name} ({field.field_type.value}): {field.description}")
        with col2:
            if st.button("Remove"):
                st.session_state.fields.clear()
                st.rerun()

    # Add new field if limit not reached
    if len(st.session_state.fields) < 1:
        new_field_name = st.text_input("Field Name")
        new_field_description = st.text_input("Field Description")
        new_field_type = st.selectbox("Field Type", [t.value for t in FieldType])

        if st.button("Add Field"):
            if new_field_name and new_field_description and new_field_type:
                try:
                    new_field = UserDefinedField(name=new_field_name, description=new_field_description, field_type=FieldType(new_field_type))
                    st.session_state.fields = [new_field]
                    st.success(f"Field '{new_field_name}' added successfully!")
                    st.rerun()
                except ValueError as e:
                    st.error(f"Error adding field: {str(e)}")
            else:
                st.error("Please fill in all field information before adding.")
    else:
        st.info("Maximum number of fields (1) reached. Remove the existing field to add a new one.")

    # Document input section
    st.header("Document Input")
    document_text = st.text_area("Paste your document text here", height=300)

    # Debug mode toggle
    st.session_state.debug_mode = st.checkbox("Enable Debug Mode")

    # Process document
    if st.button("Extract Information") and document_text and st.session_state.fields:
        with st.spinner("Extracting information..."):
            extracted_fields = extract_document_info(document_text, st.session_state.fields)
            validation_results = validate_extracted_info(extracted_fields, st.session_state.fields)

        # Display results
        st.header("Extracted Information")
        for field_name, field_data in extracted_fields.items():
            st.subheader(field_name)
            st.write(f"Value: {field_data.value}")
            st.write(f"Reference: {field_data.reference}")
            st.write(f"Validation: {validation_results[field_name]}")

        if st.session_state.debug_mode:
            st.subheader("Debug Information")
            st.json(json.loads(json.dumps(extracted_fields, default=lambda o: o.__dict__)), expanded=True)
            st.json(validation_results, expanded=True)

if __name__ == "__main__":
    main()